# Medicine Availability System

A real-time medicine availability and emergency delivery system that helps patients find essential medicines during emergencies, especially at night or in remote areas.

## Problem Statement

Patients often face difficulty finding essential medicines during emergencies due to:
- Outdated or unavailable stock information at pharmacies
- Delays in locating nearby pharmacies with required medicines
- Difficulty finding 24-hour pharmacies
- Inconvenience during urgent medical needs

## Solution

This system provides:
.
- **Real-time medicine availability** using Redis caching
- **Fast medicine search** using Elasticsearch with full-text search
- **Secure authentication** using JWT tokens
- **Background order processing** using Celery
- **Performance monitoring** using Prometheus
- **Emergency delivery** coordination
- **24-hour pharmacy filtering**

## Architecture

### System Components

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Frontend   │────▶│   FastAPI    │────▶│  PostgreSQL  │
│  (HTML/CSS/JS)│     │   Backend    │     │   /SQLite    │
└──────────────┘     └──────────────┘     └──────────────┘
                            │
                            ├──────▶ Redis (Cache)
                            │
                            ├──────▶ Elasticsearch (Search)
                            │
                            ├──────▶ Celery (Background Tasks)
                            │
                            └──────▶ Prometheus (Monitoring)
```

### Technology Stack

**Backend:**
- FastAPI - Modern Python web framework
- SQLAlchemy - Database ORM
- PostgreSQL/SQLite - Primary database
- Redis - Caching and real-time data
- Elasticsearch - Full-text search
- Celery - Background task processing
- Prometheus - Metrics and monitoring
- JWT - Authentication

**Frontend:**
- HTML5/CSS3/JavaScript
- Responsive design
- RESTful API integration

**DevOps:**
- Docker & Docker Compose
- Nginx - Frontend server and reverse proxy

## Features

### User Roles
1. **Patients** - Search medicines, place orders
2. **Pharmacies** - Manage stock, update availability
3. **Admins** - System management
4. **Delivery Personnel** - Order fulfillment (future)

### Core Functionality

#### For Patients:
- Search medicines by name, generic name, or description
- Filter by city, price, prescription requirement, and 24-hour availability
- View real-time stock availability
- Place orders with delivery address
- Track order status

#### For Pharmacies:
- Add/update medicine inventory
- Manage stock quantities and prices
- Receive order notifications
- Update pharmacy hours and location

#### System Features:
- Real-time stock caching for fast access
- Background order processing
- Stock synchronization
- Performance metrics collection
- API documentation (auto-generated by FastAPI)

## Installation

### Prerequisites
- Docker & Docker Compose (recommended)
- OR Python 3.11+, Redis, Elasticsearch (for manual setup)

### Quick Start with Docker

1. **Clone the repository**
```bash
git clone <repository-url>
cd medicine-availability-system
```

2. **Start all services**
```bash
docker-compose up -d
```

3. **Access the application**
- Frontend: http://localhost:3000
- Backend API: http://localhost:8000
- API Documentation: http://localhost:8000/docs
- Prometheus: http://localhost:9090
- Elasticsearch: http://localhost:9200

4. **Initialize the database**
```bash
docker-compose exec backend python -c "from core.database import init_db; init_db()"
```

### Manual Setup

1. **Install Python dependencies**
```bash
cd backend
pip install -r requirements.txt
```

2. **Start Redis**
```bash
redis-server
```

3. **Start Elasticsearch**
```bash
# Download and run Elasticsearch 8.x
./elasticsearch
```

4. **Configure environment variables**
Create `backend/.env`:
```env
SECRET_KEY=your-secret-key-change-in-production
DATABASE_URL=sqlite:///./medicine_system.db
REDIS_HOST=localhost
REDIS_PORT=6379
ELASTICSEARCH_HOST=localhost
ELASTICSEARCH_PORT=9200
```

5. **Initialize database**
```bash
cd backend
python -c "from core.database import init_db; init_db()"
```

6. **Run the backend**
```bash
uvicorn main:app --reload
```

7. **Run Celery worker**
```bash
celery -A tasks.celery_app worker --loglevel=info
```

8. **Serve frontend**
```bash
cd frontend
python -m http.server 3000
```

## API Documentation

### Authentication Endpoints

**POST /api/auth/signup**
- Register a new user
- Body: `{ "email", "username", "password", "role" }`

**POST /api/auth/login**
- Login and get JWT token
- Body: `{ "username", "password" }`

### Medicine Endpoints

**POST /api/medicines/search**
- Search medicines with filters
- Body: `{ "query", "city", "is_24_hours", "max_price", "requires_prescription" }`

**GET /api/medicines/{medicine_id}**
- Get medicine details by ID

### Stock Management Endpoints (Pharmacy role required)

**POST /api/stock/**
- Add new medicine to inventory

**PATCH /api/stock/{medicine_id}**
- Update medicine stock/price

**DELETE /api/stock/{medicine_id}**
- Remove medicine from inventory

### Order Endpoints (Authentication required)

**POST /api/orders/**
- Place a new order
- Body: `{ "pharmacy_id", "delivery_address", "items" }`

**GET /api/orders/**
- Get user's orders

**GET /api/orders/{order_id}**
- Get specific order details

**PATCH /api/orders/{order_id}/cancel**
- Cancel an order

## Testing

```bash
cd backend
pytest tests/ -v
```

## Monitoring

### Prometheus Metrics
Access Prometheus at http://localhost:9090

Available metrics:
- `http_requests_total` - Total HTTP requests by endpoint and status
- `http_request_duration_seconds` - Request duration histogram
- `medicine_searches_total` - Total medicine searches by city
- `orders_total` - Total orders by status
- `stock_updates_total` - Total stock updates
- `cache_hits_total` / `cache_misses_total` - Cache performance

### Logs
View application logs:
```bash
docker-compose logs -f backend
docker-compose logs -f celery-worker
```

## Project Structure

```
medicine-availability-system/
├── backend/
│   ├── api/
│   │   ├── routes/         # API route handlers
│   │   └── schemas.py      # Pydantic models
│   ├── core/
│   │   ├── config.py       # Configuration
│   │   ├── database.py     # Database setup
│   │   ├── security.py     # Authentication
│   │   ├── redis_client.py # Redis integration
│   │   ├── elasticsearch_client.py # Search integration
│   │   └── monitoring.py   # Prometheus metrics
│   ├── models/
│   │   └── database.py     # SQLAlchemy models
│   ├── tasks/
│   │   └── celery_app.py   # Background tasks
│   ├── main.py             # FastAPI application
│   ├── requirements.txt    # Python dependencies
│   └── Dockerfile
├── frontend/
│   ├── css/
│   │   └── styles.css
│   ├── js/
│   │   └── app.js
│   └── index.html
├── docker-compose.yml
├── prometheus.yml
├── nginx.conf
└── README.md
```

## Development

### Adding New Features

1. **Add database models** in `backend/models/database.py`
2. **Create API schemas** in `backend/api/schemas.py`
3. **Implement routes** in `backend/api/routes/`
4. **Add background tasks** in `backend/tasks/celery_app.py`
5. **Update frontend** in `frontend/`

### Database Migrations

For production, use Alembic:
```bash
alembic init migrations
alembic revision --autogenerate -m "Description"
alembic upgrade head
```

## Deployment

### Production Considerations

1. **Security:**
   - Change `SECRET_KEY` in production
   - Enable HTTPS
   - Use strong passwords
   - Implement rate limiting
   - Enable CORS only for trusted origins

2. **Database:**
   - Use PostgreSQL instead of SQLite
   - Set up regular backups
   - Configure connection pooling

3. **Scaling:**
   - Deploy multiple backend instances behind load balancer
   - Scale Celery workers based on load
   - Use managed Redis/Elasticsearch services

4. **Monitoring:**
   - Set up alerts in Prometheus
   - Configure log aggregation (ELK stack)
   - Monitor application performance

### Deployment Platforms
- **AWS:** EC2, RDS, ElastiCache, Amazon ES
- **Heroku:** Web dynos, Redis/ES add-ons
- **DigitalOcean:** Droplets, Managed Databases
- **Kubernetes:** For containerized deployment

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

MIT License - see LICENSE file for details

## Support

For issues and questions:
- Open an issue on GitHub
- Email: support@medifind.com

## Future Enhancements

- [ ] Real-time notifications via WebSockets
- [ ] Mobile app (React Native)
- [ ] Prescription upload and verification
- [ ] Delivery tracking with GPS
- [ ] Payment gateway integration
- [ ] Multi-language support
- [ ] Advanced analytics dashboard
- [ ] Machine learning for demand prediction
- [ ] Integration with hospital systems

## Acknowledgments

Built to solve real-world healthcare challenges and improve medicine accessibility during emergencies.
